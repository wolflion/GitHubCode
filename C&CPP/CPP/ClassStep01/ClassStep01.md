##  内容
###  2类和对象进阶01

####  2.1 构造函数
+ 作用
	+ 处理对象的初始化，不需要用户来调用它，在建立对象时自动执行，一般声明为public。(但Effective C++有建议把构造函数用户调用，而不是系统调用。)
	+ 用户没有定义构造函数，C++系统会自动生成一个构造函数，只是这个构造函数体是空的，也没有参数，不执行初始化操作。
+ 形式
	+ 无参的构造函数(也是 **默认构造函数**)
	`TIME();//无参的构造函数，也是 **默认构造函数**`
	+ 带参数的构造函数 
	`TIME(int,int,int);//带参数的构造函数`
	+ 在声明构造时指定默认参数 
	`TIME(int m=23,int n=59,int s=01);//在声明构造时指定默认参数`
	+ **参数初始化表**，在函数首部实现  TIME::TIME(int h,int m,int s):hour(h),minute(m),second(s){}//形参h的值初始化数据成员hour。
	+ 构造函数的重载 (在一个类中可以定义多个构造函数)【参数个数和类型不同】
+ 进阶
	+ 复制构造函数
    + 拷贝构造函数

####  2.2 析构函数，调用构造函数和析构函数的顺序
+ 作用
	+ 并不是删除对象，而是在撤销对象占用的内存之前完成一些清理工作。
+ 形式
	+ `~STUDENT(){;}`
+ 说明
	+ 先构造的后析构，后构造的先析构。{相当于**栈**}
	+ 影响调用顺序的情况
		+ 对象在不同的作用域定义。
		+ 对象有不同的存储类别。


####  2.3 对象数组，对象指针
+ 对象数组
	+ 类似于结构体数组，区别在于构造函数的初始化。
    + `STUDENT stu[50];`

    + ```
      STUDENT stu[2] = {   // 定义对象数组
	  STUDENT(1001,18,70), // 调用第一个元素的构造函数 
	  STUDENT(1003,20,98)  // 调用第二个元素的构造函数
	  };
      ```

+ 对象指针
	+ 指向对象的指针  
	`TIME *pt; // 定义pt为指向TIME类对象的指针变量`
	`TIME t1; pt = &t1;`
    + 指向对象成员的指针
		+ 对象数据成员
		`int *p1; p1 = &t.hour; cout << *p1 << endl;`
		+ 对象函数成员
		`void (*p)()`
    + this指针
		+ this是指向本类对象的指针，它的值是当前被调用的成员函数所在的对象的起始地址。
		+ 调用`a.volume();`，相当于`a.volume(&a);`。
		+ (*this)表示被调用的成员函数所在的对象，*this就是this所指向的对象，即当前的对象。


####  2.4 共用数据的保护
+ 共用数据：实参与形参，变量与其引用，数据及其指针。
+ 常对象
	+ `Time const t1(12,34,46);`
	+ `const Time t1(12,34,46);`
+ 常数据成员
+ 指向对象的常指针
+ 指向常对象的指针变量
+ 对象的常引用

**常对象**中的数据成员为常变量且必须要有初值，`TIME const t1(12,34,46);`等价于`const TIME t1(12,34,46);`数据成员的值都不能被修改。

常成员函数可以访问常对象中的数据成员，但仍然不允许修改常对象中数据成员的值。

`mutable int count;`//将count声明为可变的数据成员


####  2.5 对象的赋值和复制（对象的动态建立和释放）


####  2.6 静态成员
+ 静态数据成员
	+ 静态数据成员，它就为各对象所共有，而不只属于某个对象的成员，所有对象都可以引用它。{在内存中只占一份；在为对象所分配的空间中不包括静态数据成员分配空间}
	+ 静态数据成员，是在所有对象之外单独开辟空间。只要在类中定义了静态数据成员，即使不定义对象，也为静态数据成员分配空间，它可以被引用。
	+ 静态数据成员，是在程序编译时被分配空间的，到程序结束时才释放空间。
+ 静态成员函数

####  2.7 友元
+ 友元函数
	+ 将普通函数声明为友元函数
	+ 友元成员函数
+ 友元类