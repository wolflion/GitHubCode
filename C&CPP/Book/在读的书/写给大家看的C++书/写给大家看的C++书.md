##  简介
+ 在图书馆看的，知道有电子版。书在15列

##  内容

####  chap7 对象  172（187/425）
+ 7.1 创建简单的类
	+ `std::cin.get()`
	+ 静态常量可以赋初值。semicolon; perimeter
	+ C++中的static和C中static异同
+ 7.2 给类添加方法
	+ 在类里声明和定义函数，相当于做了一个inline的内联声明。
+ 7.3 对象的创建和使用
	+ 成员操作符
+ 7.4 定义构造器(构造函数)
	+ 一个类至少应有一个 **默认构造函数**。	
	+ 没有显示定义构造函数，会默认有 *空的构造函数*以及 *拷贝构造函数*。
+ 7.5 定义析构器(析构函数)
+ 7.6 this指针
	+ 避免二义性。
	+ 程序里有两个同类型的对象，编译器就会在幕后使用this指针来引用正确的对象和属性。

####  chap8 类的继承  199（214/425）
+ 8.1 基本的继承
	+ 猫类和狗类分别继承自宠物类。
	+ is-a，是一个
	+ has-a，有一个，聚合
	+ **只要有可能，就不使用继承机制。**
+ 8.2 继承机制中的构造函数和析构函数
	+ `Cat::Cat(std::string theName):Pet(theName){}`
+ 8.3 访问控制
	+ *先写public,然后写protected,private*
+ 8.4 覆盖方法
	+ **覆盖**是什么意思？
+ 8.5 重载方法
	+ 输入参数个数和类型有不同； *返回值不同*是不是我要确定？
+ 8.6 友元关系
	+ **应该只有在没有办法时才使用**

####  chap9 高级OOP技术  228（243/425）
+ 9.1 静态属性和静态方法
	+ 静态属性是在同一个类的所有实例之间共享的，不属于某个特定的对象。但为什么要告诉编译器这个静态属性属于哪个类（为什么确定下哪些类才能访问？）。
	+ 不能在静态方法里访问非静态元素（原因：静态方法不是属于某个特定的对象，而是由全体对象共享的，这意味着它们无法访问this指针）。
+ 9.2 虚方法
	+ 虽然在子类中对play()方法进行了覆盖，但实际调用的是基类的play()方法。
	+ 声明虚方法，只是为了告诉编译器，应该根据这两个指针在运行时的类型而有选择的调用正确的方法。
	+ 析构器，都是虚方法。｛这就是为啥，都要让析构器声明为虚析构函数｝
+ 9.3 抽象方法
	+ 要想使用某个抽象方法，就必须在子类里实现它。
	+ `virtual void play()＝0;`
+ 9.4 重载操作符
+ 9.5 <<操作符
+ 9.6 多继承
+ 9.7 虚继承
   + 通过虚继承`：virtual subclass`某个基类，就是在告诉编译器：从当前这个类再派生出来的子类只能拥有那个基类的一个实例。

#### chap10 错误处理和调试  270（285/425）
+ 10.1 调试技巧
+ 10.2 让函数返回错误代码。
+ 10.3 assert()还没有在程序中用过

####  chap14 杂项  380（395/425）
+ 14.1 再论字符串
	+ substr()提取子字符串
	+ 添加字符串
	+ 搜索字符串


##  收获


##  履历
+ 20160423 chap7 对象 看完书并做笔记
+ 20160425 chap8 继承；chap14.1 杂项  看完书并做笔记
+ 20160426 chap9 高级OOP技术【 **需要再看**】，chap10.1/2/3 错误处理和调试 


