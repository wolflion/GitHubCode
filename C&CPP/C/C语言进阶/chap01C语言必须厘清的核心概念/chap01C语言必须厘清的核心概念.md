##  缘起
+ 

##  内容
###  1.1 堆栈
+ 堆：动态存储结构。数据段中的自由存储区。**向高地址方向“生长”**
+ 栈：在i386的体系里，栈顶是ESP的寄存器。保存了一个函数调用时所需要的维护信息。**向低地址方向“生长”**含以下两方面：
    + 函数的返回地址和参数
    + 临时变量：函数的非静态局部变量和编译器自动生成的

###  1.2 全局变量和局部变量
+ 全局变量：可分为
    + static
    + extern：可以被其他源文件中的函数引用。

###  1.3 生存期和作用域
+ 1.3.1 生存期：变量占用内存或寄存器的时长。
+ **存储类别**
    + auto
    + register
    + static
    + extern
+ 1.3.2 作用域：在有效的前提下，就近原则。

###  1.4 内部函数和外部函数
+ 内部 `static fun(int x)`
+ 外部 `extern fun(int x)` //没加关键字，也是外部函数。

###  1.5 指针变量

###  1.6 指针数组和数组指针
+ 指针数组 `int *p[8]` //变量名先与[]结合，说明p是一个数组。 
+ 数组指针 `int(*p)[8]` //变量名与8结合，说明是个指针

###  1.7 指针函数和函数指针
+ 指针函数 （同上） `int *fun()`  *带指针的函数*，本质是个函数。
+ 函数指针 `int (*fun)()`  *本质上是个指针，所以每个函数都有一个入口地址*。函数指针指向的就是函数的入口地址。

###  1.8 传值和传址
+ *传值*：对形参的修改只是修改实参的备份，不会影响到实参。[例E1-08-01.c]
+ *传址*：函数调用过程中参数传递的是地址，**形参和实参共用一个空间**。

###  1.9 递归与嵌套
+ **嵌套调用**：在一个函数中调用另一个函数。*但不能嵌套定义*。**因为C语言的各个函数之间是互相平行的关系。**
+ **函数递归调用**（嵌套调用的特例）
    + 要有递归调用的停止条件。
+ *这两个代码，就不用本书中的了，我直接根据之前的代码给个参考就OK了。*

###  1.10 结构体
+ *只是简单的介绍了为什么要有结构体，以及结构体的定义。我也从别的地方链个代码过来，就OK。*
    + **内存大小**是由所有成员各自占用的内存大小之和。

###  1.11 共用体
+ *只是简单的介绍了共用体的定义。我也从别的地方链个代码过来，就OK。*
    + **内存大小**是由所有成员中占用的内存最大的那个。
    + 结构体，共用体可以互相嵌套，但 **要注意其中成员的引用方法**

###  1.12 枚举
+ 默认值从0开始，但中途有定义新值了，后面的值就自动加1。`enum eu2{e=3,f=2,g=1,h,};//h的值就是2。`
+ **在同一个作用域内不能出现重名的枚举变量名。** [E1-12-01.c]

###  1.13 位域
+ **位域：** 把存储空间中的二进制位划分为几个不同的区域，并说明每个区域的位数，每个域有一个域名，允许在程序中按域名进行操作。  **怎么算sizeof()是个麻烦事**
+ [E1-13-01.c]
+ *lionel这部分用得不太多，暂时先不看吧，大概了解这个概念和用法*

## 学习履历和收获
+ 2017-01-18：一个番茄钟看到chap1.7，基本都理解，但代码没运行。
+ 2017-10-05：花了1个半番茄钟，看完了chap1.8-chap1.13。其中1.13部分没有好好的看，感觉用处不大，后面再回过头来复习一下，如果需要的话。