## 0 缘起
+ 有一点编程经验和积累，想系统的学习下STL，以前都是随意做的笔记，现在想着成主题的输出一下。
+ 书的原型是ISBN:9787302421757 [《C++泛型STL原理和应用》](https://item.jd.com/10157653876.html)，是从图书馆借的国内大学教材，先把这个读完了，如果有可能的话，就在相应的章节再写一个plus版本。

## 1 内容
### 1.1 泛型和模板
#### 1.1.1 泛型的概念
+ 泛型（generic type）：就是一种通用类型。
+ `T max( T x, T y) {}`  //这里T是类型**占位符**。

#### 1.1.2 C++模板及其定义
+ **模板**：除了需要声明类型占位符之外，其它内容应与目标实体代码完全相同。 声明一个模板时，需在实体代码前面，加一条说明语句。*前面是template关键字。*
	+ 函数模板
		+ `template<typename T, typename R, typename S>  T max(R x, S y){}`
	+ 类模板
		+ 在声明语句前加 `template<typename T>`  

#### 1.1.3 几点说明和小结
+ `template<typename T>` 早期也写成 `template<class T>`，但不支持这么写
+ C++11和14中，给关键字 **auto** 增加了新的语义，同时增加了 **decltype表达式** 
	+ auto关键字是为自动推导数据类型所设 `auto i=100;`
	+ 之前auto只对系统的内置数据推荐有效，现在利用*编译器的类型记忆能力*，可以记住自定义的类型。
	+ 变量类型难以确定的问题主要出现在函数的返回值上，因此函数的返回值类型的位置常常会出现auto关键字，称为 **auto返回值占位**
	+ `auto Multiply(T t, U u)->decltype(t*u) {return t*u;}`
+ 把auto看做数据类型的话，auto其实也可以算一种泛型，不过它无须关键字typename声明。
+ C++新标准引入了**变量模板**的概念。`pi<T>` 【作者没有介绍更多，可以翻看C++11】

### 1.2 关于模板参数
####  1.2.1 模板参数的种类
+ 类型参数
	+ 以类模板作为函数实参的例子 `MyTest<Test1<int>>TT;`
+ 非类型参数
	+ `template <typename T，/*类型参数*/ int b/*非类型参数*/> `
+ 模板定义型参数
	+ C++也允许以类模板的定义作为类模板参数
		+ **需要的目的：** 除了强调这个参数的实参必须为类模板之外，还强调这个类模板所具有的参数个数。

####  1.2.2 模板形参和实参的结合
+ 函数模板实参的隐式提供
	+ `add<int>(45,46);` 直接变成 `add(45,46);`
+ 指针实参
	+ 在C++中，指针被看作一种数据类型。
	+ 见具体的代码； 【*作者没有描述，我还没太懂这部分*】
+ 修饰字const和&的使用
	+ 见具体的代码示例； 【*没见过具体的应用场景*】

### 1.3 特化模板和模板具现规则
####  1.3.1 特化(特列化)模板
+ **特化(特列化)模板**：为有特殊算法要求的数据类型另行编写模板
	+ 通用模板：门票10块
	+ 特化模板：学生和老人半价
+ 函数模板中的特化模板
	+ 在实体代码前加以下声明 `tmplate<>`
+ 类模板的特化和偏特化
	+ **偏特化：**只特化参数中的某一个或某几个
	+ 偏特化模板的写法 `template<typename T2> struct Test<int,T2>{}`
	+ 全特化模板的写法 `template<> struct Test<int,float>{}`

####  1.3.2 模板的具现
+ 因为有了以上泛型模块的共存，编译器就需要选择一个生成实体模块代码，就有了规则。
+ 具体的优先顺序
	+ 特化模板（函数或类）
	+ 偏特化模板（函数或类）
	+ 普通模板（函数或类）
	+ 系统

### 1.4 右值引用和模板
+ **转移语义**是C11推出的新概念和新技术。
#### 1.4.1 右值引用
+ **右值：** 只能出现在赋值运算符右边。*仅能代表数据；匿名，无固定地址的对象。*
+ **左值：** 既可以出现在赋值运算符左边，又可以出现在赋值运算符右边。*有名字，有固定地址的表达式*
+ 右值引用
	+ C11之前有两种表示方式 `T& 别名 = lvalue;//引用` 和 `const T& 别名 = lvalue;//常引用`
	+ C11之后仅定义一种：`const T& 别名 = rvalue;`
		+ *强行为右值命名一个变量名，目的就是为延长右值生命期。* 
		+ **右值的非常量引用** `T&& 名称=rvalue;`

#### 1.4.2 右值引用的应用1--转移语义
+ **深拷贝**
+ **浅拷贝**

#### 1.4.3 右值引用的应用2--转移函数move()
+ 右值引用有好处后，左值也想利用，move的原型 `T&& move(T& val);`

#### 1.4.4 右值引用的应用3--参数完美转发模板()
+ **参数转发**
+ 1 完美转发问题的提出及解决思路
+ 2 模板参数类型推导规则--引用符折叠规则
+ 3 参数类型正确转发的保证--forward()函数模板
	+ `static_cast()`：这个转换只对参数为右值时有用。
	+ C++11将`static_cast()`封装成函数模板std::forward，于是`Func(forwad<T>(a));`

### [本章代码](https://coding.net/u/wolflion/p/Example/git/blob/master/STLChap1.cpp) 

##  别的教材相应章节
+ [《C++STL开发技术导引》](https://book.douban.com/subject/2128514/) chap2 C++模板技术 P39/454
	+ 内容
		+ 2.4 函数模板重载  P44  *编译器调用规则*
		+ 2.5 类模板继承  P44
		+ 代码到时再一起提交。
	+ 问题
		+ 模板和宏是什么关系？【lionel]

##  阅读版本与遇到的问题
+ 2017-01-14两个番茄钟：1.1节理解并代码完成，1.2节刚开始看
	+ C++新标准引入了**变量模板**的概念。`pi<T>` 【作者没有介绍更多，可以翻看C++11】
	+ 以类模板作为函数实参的例子,简单的能看懂，但到真实应用场景中，目前还真说不好。
+ 2017-01-15两个番茄钟：1.2和1.3节理解并代码完成 
	+ 目前这些只是知道了，还没完全记住，更不清楚应用场景。 
+ 2017-01-16两个番茄钟：1.4结束
	+ 这部分只是按课本看了，并没有完全消化掉，需要再回来看看。
	+ *是不是得结合C++11来一起翻看？*【lionel】
+ 2017-01-17 看了下《C++STL开发技术导引》中的chap2 

